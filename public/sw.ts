/// <reference lib="webworker" />

import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute, NavigationRoute } from "workbox-routing";
import {
	CacheFirst,
	NetworkFirst,
	StaleWhileRevalidate,
} from "workbox-strategies";
import { CacheableResponsePlugin } from "workbox-cacheable-response";
import { ExpirationPlugin } from "workbox-expiration";
import { BackgroundSyncPlugin } from "workbox-background-sync";

declare let self: ServiceWorkerGlobalScope;

// Precache all assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Cache pages with NetworkFirst strategy
registerRoute(
	({ request }) => request.mode === "navigate",
	new NetworkFirst({
		cacheName: "pages-cache",
		plugins: [
			new CacheableResponsePlugin({ statuses: [0, 200] }),
			new ExpirationPlugin({ maxEntries: 50, maxAgeSeconds: 24 * 60 * 60 }), // 1 day
		],
	})
);

// Cache static assets with CacheFirst
registerRoute(
	({ request }) =>
		request.destination === "script" ||
		request.destination === "style" ||
		request.destination === "image" ||
		request.destination === "font" ||
		request.url.includes("assets/home-organizer/images/logo.png"),
	new CacheFirst({
		cacheName: "static-assets",
		plugins: [
			new CacheableResponsePlugin({ statuses: [0, 200] }),
			new ExpirationPlugin({
				maxEntries: 100,
				maxAgeSeconds: 7 * 24 * 60 * 60,
			}), // 7 days
		],
	})
);

// Handle all app routes
const appRoutes = [
	"/",
	"/inventory",
	"/inventory/categories",
	"/inventory/items",
	"/inventory/categories/new",
	"/inventory/categories/:id",
	"/inventory/categories/:id/edit",
	"/inventory/categories/:id/delete",
	"/inventory/items/new",
	"/inventory/items/:id",
	"/inventory/items/:id/edit",
	"/inventory/items/:id/delete",
	"/settings",
	"/settings/theme",
	"/settings/notifications",
	"/settings/appearance",
	"/settings/localization",
	"/settings/data",
	"/reports",
	"/reports/categories",
	"/reports/categories/:id",
	"/privacy",
	"/help",
];

// Cache app routes with StaleWhileRevalidate
registerRoute(
	({ request }) => request.mode === "navigate",
	new StaleWhileRevalidate({
		cacheName: "pages-cache",
		plugins: [
			new CacheableResponsePlugin({ statuses: [0, 200] }),
			new ExpirationPlugin({
				maxEntries: 50,
				maxAgeSeconds: 24 * 60 * 60, // 24 hours
			}),
		],
	})
);

// Handle navigation requests for app routes
const handler = createHandlerBoundToURL("/index.html");
const navigationRoute = new NavigationRoute(handler, {
	allowlist: appRoutes.map(
		(route) => new RegExp(route.replace(/:\w+/g, "[^/]+"))
	),
});
registerRoute(navigationRoute);

// Listen for updates and skip waiting to activate new service worker
self.addEventListener("message", (event) => {
	if (event.data && event.data.type === "SKIP_WAITING") {
		self.skipWaiting();
	}
});

// Enhanced fetch handler for offline support with better error handling
self.addEventListener("fetch", (event) => {
	if (event.request.method !== "GET") return;

	event.respondWith(
		(async () => {
			try {
				const cache = await caches.open("pages-cache");
				const cachedResponse = await cache.match(event.request);

				if (cachedResponse) {
					return cachedResponse;
				}

				try {
					const response = await fetch(event.request);
					if (response.ok) {
						cache.put(event.request, response.clone());
					}
					return response;
				} catch (networkError) {
					// Check if request is for a page/HTML
					if (
						event.request.mode === "navigate" ||
						event.request.headers.get("Accept")?.includes("text/html")
					) {
						const offlineResponse = await cache.match("/offline.html");
						if (offlineResponse) {
							return offlineResponse;
						}
					}

					return new Response(
						"You are offline. Please check your internet connection.",
						{
							status: 503,
							statusText: "Service Unavailable",
							headers: new Headers({ "Content-Type": "text/plain" }),
						}
					);
				}
			} catch (error) {
				console.error("Fetch handler error:", error);
				return new Response("An error occurred", { status: 500 });
			}
		})()
	);
});

// Handle background sync
self.addEventListener("sync", (event) => {
	if (event.tag === "sync-inventory") {
		event.waitUntil(syncInventory());
	}
});

async function syncInventory() {
	const cache = await caches.open("inventory-updates");
	const requests = await cache.keys();

	return Promise.all(
		requests.map(async (request) => {
			try {
				const response = await fetch(request);
				if (response.ok) {
					await cache.delete(request);
				}
				return response;
			} catch (error) {
				console.error("Sync failed:", error);
				return new Response(null, { status: 500 });
			}
		})
	);
}

// Handle push notifications
self.addEventListener("push", (event) => {
	const data = event.data?.json() ?? {};
	const title = data.title || "New Notification";
	const options = {
		body: data.body || "You have a new notification",
		icon: "/icon.png",
		badge: "/badge.png",
	};

	event.waitUntil(self.registration.showNotification(title, options));
});

// Handle notification clicks
self.addEventListener("notificationclick", (event) => {
	event.notification.close();
	event.waitUntil(self.clients.openWindow("/"));
});
